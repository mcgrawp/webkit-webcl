<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebCL Create a Context for Each Device.</title>
<script src="../resources/js-test-pre.js"></script>
<script src="../resources/kernels.js"></script>
<script src="../resources/logger.js"></script>
<script src="../resources/webcl-proxy.js"></script>
<script src="../resources/webcl-test-utils.js"></script>

<script>

/**
 * FIXME: This test run as expected, but the devices used are ignored because of
 * the proxy.
 * When the DEVICE_TYPE_ALL is been working, just remote this comment.
 */

var wclUtils;
var data;
var data_size;
var err;

var platformCPU;
var platformGPU;
var deviceCPU;
var deviceGPU;
var contextCPU;
var contextGPU;
var queueCPU;
var queueGPU;
var programCPU;
var programGPU;
var kernelCPU;
var kernelGPU;

var workGroupSizeCPU;
var workGroupSizeGPU;
var globalWorkSizeCPU;
var globalWorkSizeGPU;
var localWorkSizeCPU;
var localWorkSizeGPU;

var inputCPU;
var inputGPU;
var outputCPU;
var outputGPU;
var resultCPU;
var resultGPU;

function runTest() {
    var i;
    var j;
    var args;
    var ndRangeDict;
    var kernelSource;

    try {

        proxy = WebCLProxy;
        wclUtils = WebCLTestUtils;
        platformCPU = proxy.getWCLPlatform();
        platformGPU = proxy.getWCLPlatform();

        deviceCPU = platformCPU.getWCLDevice(proxy.DEVICE_TYPE_CPU);
        deviceGPU = platformGPU.getWCLDevice(proxy.DEVICE_TYPE_GPU);

        contextCPU = platformCPU.createWCLContext();
        contextGPU = platformGPU.createWCLContext();

        queueCPU = contextCPU.createWCLCommandQueue(deviceCPU, null);
        queueGPU = contextGPU.createWCLCommandQueue(deviceGPU, null);

        kernelSource = Kernels.square;
        if (!kernelSource) {
            testFailed("No kernel named: " + "square");
            return;
        }

        programCPU = contextCPU.createWCLProgram(kernelSource);
        programGPU = contextGPU.createWCLProgram(kernelSource);

        programCPU.build(deviceCPU);
        programGPU.build(deviceGPU);

        kernelCPU = programCPU.createWCLKernel("square");
        kernelGPU = programGPU.createWCLKernel("square");

        data_size = kernelGPU.getWorkGroupInfo(deviceGPU, proxy.KERNEL_WORK_GROUP_SIZE)[0];
        resultCPU = new Int32Array(data_size);
        resultGPU = new Int32Array(data_size);

        data = wclUtils.getRandomVector(data_size, 100);
        data = new Int32Array(data);

        inputCPU = contextCPU.createWCLBuffer(proxy.MEM_READ_ONLY,
                                                Int32Array.BYTES_PER_ELEMENT * data_size,
                                                null);
        inputGPU = contextGPU.createWCLBuffer(proxy.MEM_READ_ONLY,
                                                Int32Array.BYTES_PER_ELEMENT * data_size,
                                                null);

        outputCPU = contextCPU.createWCLBuffer(proxy.MEM_WRITE_ONLY,
                                                Int32Array.BYTES_PER_ELEMENT * data_size,
                                                null);
        outputGPU = contextGPU.createWCLBuffer(proxy.MEM_WRITE_ONLY,
                                                Int32Array.BYTES_PER_ELEMENT * data_size,
                                                null);

        args = {};
        args.buffer = inputCPU;
        args.blockingWrite = true;
        args.bufferOffset = 0;
        args.numBytes = Int32Array.BYTES_PER_ELEMENT * data_size;
        args.data = data;

        queueCPU.enqueueWriteBuffer(args);

        args.buffer = inputGPU;
        queueGPU.enqueueWriteBuffer(args);

        kernelCPU.setWCLKernelArgs(0, inputCPU);
        kernelCPU.setWCLKernelArgs(1, outputCPU);
        kernelCPU.setWCLKernelArgs(2, data_size, proxy.UINT);

        kernelGPU.setWCLKernelArgs(0, inputGPU);
        kernelGPU.setWCLKernelArgs(1, outputGPU);
        kernelGPU.setWCLKernelArgs(2, data_size, proxy.UINT);

        globalWorkSizeCPU = new Int32Array(1);
        globalWorkSizeGPU = new Int32Array(1);
        localWorkSizeCPU = new Int32Array(1);
        localWorkSizeGPU = new Int32Array(1);

        globalWorkSizeCPU[0] = globalWorkSizeGPU[0] = data_size;
        localWorkSizeCPU[0] = data_size / 2;
        localWorkSizeGPU[0] = data_size / 2;

        ndRangeDict = {};
        ndRangeDict.kernel = kernelCPU;
        ndRangeDict.globalWorkOffset = new Int32Array(0);
        ndRangeDict.globalWorkSize = globalWorkSizeCPU;
        ndRangeDict.localWorkSize = localWorkSizeCPU;
        ndRangeDict.globalWorkOffset[0] = 0;
        queueCPU.enqueueNDRangeKernel(ndRangeDict);

        ndRangeDict = {};
        ndRangeDict.kernel = kernelGPU;
        ndRangeDict.globalWorkOffset = new Int32Array(0);
        ndRangeDict.globalWorkSize = globalWorkSizeGPU;
        ndRangeDict.localWorkSize = localWorkSizeGPU;
        ndRangeDict.globalWorkOffset = null;
        queueGPU.enqueueNDRangeKernel(ndRangeDict);

        args = {};
        args.buffer = outputCPU;
        args.blockingRead = true;
        args.bufferOffset = 0;
        args.numBytes = Int32Array.BYTES_PER_ELEMENT * data_size;
        args.data = resultCPU;

        queueCPU.enqueueReadBuffer(args);

        args.buffer = outputGPU;
        args.data = resultGPU;
        queueGPU.enqueueReadBuffer(args);

        queueCPU.finish();
        queueGPU.finish();

        console.log(resultCPU);
        console.log(resultGPU);
        for (j = 0; j < data_size; j++) {
            if (resultCPU[j] !== resultGPU[j]) {
                testFailed("In position " + j + ", different results: " +
                            resultCPU[j] + " != " + resultGPU[j]);
                return;
            }
        }

        // TODO: release memory

        testPassed("");
    } catch (e) {
        testFailed("WebCL Test: Create a context for each device has failed. ; Message: " + e.message);
    }
}
</script>

</head>
<body>
<div id="description"></div>
<div id="console"></div>
<script>
    description("Create a context for each device");
    runTest();
</script>
<script src="../resources/js-test-post.js"></script>
</body>
</html>
