<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Render Buffer Interoperability Test</title>

<script src="../resources/js-test-pre.js"></script>
<script src="../resources/kernels.js"></script>

<script id="vertex" type="x-shader">
    attribute vec2 aPos;
    attribute vec2 aTexCoord;
    varying   vec2 vTC;

    void main(void) {
        gl_Position = vec4(aPos, 0., 1.);
        vTC = aTexCoord;
    }
</script>

<script id="fragment" type="x-shader">
#ifdef GL_ES
precision highp float;
#endif

    uniform sampler2D samp;
    varying vec2 vTC;

    void main(void) {
       gl_FragColor = texture2D(samp, vTC);
    }
</script>

<script>
    if (window.testRunner) {
        testRunner.overridePreference("WebKitWebGLEnabled", "1");
    }

    var gl;
    var programGL;
    var vboGL;
    var vboGLTexCoord;
    var frameBuffer;
    var texBuffer;
    var renderGLIn;
    var renderGLOut;

    var pixelWidth        = 2;
    var pixelHeight       = 2;
    var pixelDepth        = 1;
    var pixelSizeInBytes  = 4;
    var pixelNumber;
    var colorData;

    var cl;
    var context;
    var cmdQueue;
    var kernel;
    var renderCLIn;
    var renderCLOut;

    var origin;
    var region;
    var kResult;
    var globalWorkSize;

    function getById(id) {
        var elem;

        elem = document.getElementById(id);
        if (!elem) {
            testFailed("In getById: no id found");
        }

        return elem.innerHTML;
    }

    function getCanvasContext(canvas) {
        try {
            gl = canvas.getContext("webgl", {preserveDrawingBuffer: true})
                 || canvas.getContext("experimental-webgl", {preserveDrawingBuffer: true});
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
            throw (new Error("In getCanvasContext: " + e.message));
        }
    }

    function initGL() {
        var canvas;

        try {
            canvas = document.getElementById("canvas");
            getCanvasContext(canvas);
            initShaders();
            initGLBuffers();
        } catch (e) {
            throw (new Error("In initGL: " + e.message));
        }
    }

    function initGLBuffers() {
        var vertices;
        var texCoords;
        var aPosLoc;
        var aTexLoc;
        var sampLoc;
        var frameBufferStatus;

        aPosLoc = gl.getAttribLocation(programGL, "aPos");
        aTexLoc = gl.getAttribLocation(programGL, "aTexCoord");
        vertices = [
            0.5,  0.5,
            -0.5,  0.5,
            0.5, -0.5,
            -0.5, -0.5
        ];
        texCoords = [0, 0,  1, 0,  1, 1,  0, 1];

        try {
            vboGL = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vboGL);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
                          gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aPosLoc);
            gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            vboGLTexCoord = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vboGLTexCoord);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords),
                          gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aTexLoc);
            gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            texBuffer = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texBuffer);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixelWidth, pixelHeight,
                          0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                             gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,
                             gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,
                             gl.CLAMP_TO_EDGE);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,
                             gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);

            renderGLIn = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderGLIn);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, pixelWidth,
                                   pixelHeight);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            renderGLOut = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderGLOut);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, pixelWidth,
                                   pixelHeight);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            frameBuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

            gl.bindRenderbuffer(gl.RENDERBUFFER, renderGLOut);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.RENDERBUFFER, renderGLOut);
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            frameBufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (frameBufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
                throw (new Error("In initGLBuffers: Failed to make complete frame buffer object"));
            }

            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        } catch(e) {
            throw e;
        }
    }

    function initShaders() {
        var shader;
        var vShaderSrc;
        var fShaderSrc;
        var vShader;
        var fShader;

        programGL = gl.createProgram();

        vShaderSrc = getById("vertex");
        fShaderSrc = getById("fragment");

        vShader = gl.createShader(gl.VERTEX_SHADER);
        fShader = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(vShader, vShaderSrc);
        gl.shaderSource(fShader, fShaderSrc);

        gl.compileShader(vShader);
        if (gl.getShaderParameter(vShader, gl.COMPILE_STATUS) === 0) {
            testFailed("In vertex shader: " + gl.getShaderInfoLog(shader));
        }

        gl.compileShader(fShader);
        if (gl.getShaderParameter(fShader, gl.COMPILE_STATUS) === 0) {
            testFailed("In fragment shader: " + gl.getShaderInfoLog(shader));
        }

        gl.attachShader(programGL, vShader);
        gl.attachShader(programGL, fShader);
        gl.linkProgram(programGL);
        gl.useProgram(programGL);
    }

    function initCLBuffers() {
        try {
            texColorData = [
                255, 255, 255, 255,
                255, 0,   0,   255,
                0,   255, 0,   255,
                0,   0,   255, 255
            ];

            renderCLIn = context.createFromGLRenderbuffer(webcl.MEM_READ_ONLY,
                                                          renderGLIn);
            renderCLOut = context.createFromGLRenderbuffer(webcl.MEM_WRITE_ONLY,
                                                           renderGLOut);

            pixelNumber    = pixelWidth * pixelHeight * pixelSizeInBytes;
            colorData      = new Uint8Array(texColorData);
            kResult        = new Uint8Array(pixelNumber);
            origin         = new Int32Array([0, 0, 0]);
            region         = new Int32Array([pixelWidth, pixelHeight, pixelDepth]);
            globalWorkSize = new Int32Array([pixelWidth, pixelHeight]);
        } catch (e) {
            throw (new Error("In initCLBuffers:: " + e.message));
        }
    }

    function initCL() {
        var contextProperties;
        var devices;
        var device;
        var kernelSrc;
        var programCL;

        try {
            cl = webcl;
            if (!cl) {
                throw (new Error("In initCL: WebCL object is not defined"));
            }

            cl = cl.getExtension("KHR_GL_SHARING");
            if (!cl) {
                throw (new Error("In initCL: GL Extension is not supported"));
            }

            platforms = cl.getPlatforms();
            if (!platforms.length) {
                throw (new Error("In initCL: Platform is not defined"));
            }
            platform = platforms[0];

            devices = platform.getDevices(cl.DEVICE_TYPE_DEFAULT);
            if (!devices.length) {
                throw (new Error("In initCL: Devices is not valid"));
            }
            device = devices[0];

            contextProperties = {platform: platform, devices: devices};
            context = cl.createContext(contextProperties);
            if (!context) {
                throw (new Error("In initCL: It was not possible to create WebCLContext"));
            }

            kernelSrc = Kernels.copyTexture;
            if (!kernelSrc) {
                throw (new Error("In initCL: No kernel source"));
            }
            programCL = context.createProgram(kernelSrc);
            programCL.build([device]);

            cmdQueue = context.createCommandQueue(device);
            kernel = programCL.createKernel("copyTex");

            initCLBuffers();
        } catch (e) {
            throw e;
        }
    }

    function runKernel() {
        var i;

        try {
            kernel.setArg(0, renderCLIn);
            kernel.setArg(1, renderCLOut);

            gl.finish();
            cmdQueue.enqueueAcquireGLObjects([renderCLIn, renderCLOut]);
            cmdQueue.enqueueWriteImage(renderCLIn, true, origin, region, 0,
                                       colorData);
            cmdQueue.enqueueNDRangeKernel(kernel, null, globalWorkSize, null);
            cmdQueue.enqueueReadImage(renderCLOut, true, origin, region, 0,
                                      kResult);
            cmdQueue.enqueueReleaseGLObjects([renderCLIn, renderCLOut]);
            cmdQueue.finish();

            for (i = 0; i < pixelNumber; i++) {
                if (colorData[i] !== kResult[i]) {
                    throw (new Error("In runKernel: results are different. Position [" + i + "], " + colorData[i] + " != " + kResult[i]));
                }
            }
        } catch (e) {
            throw e;
        }
    }

    function getPixels() {
        var pixels;
        pixels = new Uint8Array(pixelNumber);

        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        gl.readPixels(0, 0, pixelWidth, pixelHeight, gl.RGBA,
                      gl.UNSIGNED_BYTE, pixels);
        for (i = 0; i < pixelNumber; i++) {
            if (pixels[i] !== kResult[i]) {
                throw (new Error("In getPixels: results are different. Position [" + i + "], " + pixels[i] + " != " + kResult[i]));
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return pixels;
    }

    function draw() {
        var pixels;

        try {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            pixels = getPixels();
            gl.bindTexture(gl.TEXTURE_2D, texBuffer);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixelWidth, pixelHeight, 0,
                          gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            gl.bindBuffer(gl.ARRAY_BUFFER, vboGLTexCoord);
            gl.bindBuffer(gl.ARRAY_BUFFER, vboGL);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        } catch(e) {
            throw e;
        }
    }

    function runTest() {
        try {
            initGL();
            initCL();
            runKernel();
            draw();
            testPassed("");
        } catch(e) {
            testFailed(e.message);
        }
    }

</script>

</head>
<body>
<div id="description"></div>
<canvas id="canvas" width="200" height="200"></canvas>
<div id="console"></div>
<script>
    description(document.title);
    runTest();
</script>
<script src="../resources/js-test-post.js"></script>
</body>
</html>
